<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PLNT.earth Space Screensaver</title>
  <style>
    :root {
      --primary-color: #7C3AED;
      --primary-light: #8B5CF6;
      --primary-dark: #6D28D9;
      --secondary-color: #F59E0B;
      --secondary-light: #FBBF24;
      --secondary-dark: #D97706;
      --text-color: #E5E7EB;
      --text-muted: #9CA3AF;
      --bg-color: #0B0F19;
      --bg-secondary: #1F2937;
      --bg-tertiary: #374151;
      --box-bg: rgba(30, 41, 59, 0.6);
      --box-border: rgba(255, 255, 255, 0.1);
      --moon-color: #F7FAFC;
      --moon-shadow: #0F172A;
      --full-moon-color: #FFFF77;
      --new-moon-color: #0A0A0F;
    }

    /* Cosmic theme */
    [data-theme="cosmic"] {
      --full-moon-color: #FF6EC7;
      --new-moon-color: #1A0B2E;
      --secondary-color: #B388FF;
      --primary-color: #7C4DFF;
      --box-bg: rgba(138, 43, 226, 0.1);
      --box-border: rgba(147, 112, 219, 0.3);
    }
  
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      background-color: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: white;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
    }
    
    .logo-container {
      position: fixed;
      top: 40px;
      left: 40px;
      font-size: 24px;
      font-weight: bold;
      z-index: 100;
      display: flex;
      align-items: center;
      opacity: 0.6;
    }
    
    .logo-text {
      animation: bobUpDown 4s ease-in-out infinite;
    }
    
    @keyframes bobUpDown {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    @keyframes fadeInOut {
      0% { opacity: 0.4; }
      50% { opacity: 0.7; }
      100% { opacity: 0.4; }
    }
    
    .moon {
      width: 12px;
      height: 12px;
      background-color: var(--secondary-color);
      border-radius: 50%;
      position: absolute;
      box-shadow: 0 0 10px 2px var(--secondary-color);
      transition: transform 1.5s cubic-bezier(0.455, 0.03, 0.515, 0.955);
    }
    
    .clock {
      position: fixed;
      bottom: 40px;
      right: 40px;
      font-size: 36px;
      font-weight: 300;
      z-index: 100;
      color: rgba(255, 255, 255, 0.8);
      text-shadow: 0 0 20px rgba(100, 200, 255, 0.6);
    }
    
    .moon-countdown {
      position: fixed;
      bottom: 85px;
      right: 40px;
      font-size: 16px;
      font-weight: 300;
      z-index: 100;
      color: rgba(255, 255, 255, 0.7);
      text-shadow: 0 0 10px rgba(100, 200, 255, 0.4);
      text-align: right;
    }
    
    .click-button {
      position: fixed;
      bottom: 40px;
      left: 40px;
      z-index: 100;
      background: var(--box-bg);
      border: 2px solid var(--box-border);
      color: white;
      padding: 10px 15px;
      font-size: 16px;
      border-radius: 20px;
      cursor: pointer;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      box-shadow: 0 0 15px rgba(100, 150, 255, 0.4);
    }
    
    .click-button:hover {
      background: rgba(40, 80, 150, 0.7);
      box-shadow: 0 0 20px rgba(100, 150, 255, 0.6);
      border-color: var(--secondary-color);
    }
    
    .click-log {
      position: fixed;
      bottom: 100px;
      left: 40px;
      width: 250px;
      max-height: 200px;
      overflow-y: auto;
      background: rgba(10, 20, 40, 0.8);
      border: 1px solid var(--box-border);
      border-radius: 10px;
      padding: 15px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.9);
      z-index: 99;
      backdrop-filter: blur(5px);
      display: block;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    
    .click-log::-webkit-scrollbar {
      display: none;
    }
    
    .click-log p {
      margin: 5px 0;
      border-bottom: 1px solid rgba(100, 150, 255, 0.2);
      padding-bottom: 5px;
    }
    
    .hide-cursor {
      cursor: none;
    }
    
    .info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      font-size: 12px;
      color: var(--text-muted);
      z-index: 100;
    }
    
    .theme-indicator {
      position: fixed;
      top: 40px;
      right: 40px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.6);
      z-index: 100;
      text-align: right;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .theme-indicator.show {
      opacity: 1;
    }
    
    .spacecraft {
      position: absolute;
      width: 60px;
      height: 30px;
      z-index: 90;
      transition: transform 0.2s ease;
      pointer-events: none;
    }
    
    .spacecraft.rocket {
      background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTIuNTMsMTAuNjRMOCw4TDEwLjY0LDIuNTNDMTAuODEsMi4yIDExLjE2LDIgMTEuNSwyQzExLjg0LDIgMTIuMTksMi4yIDEyLjM2LDIuNTNMMTUsOEwyMC40NywxMC42NEMyMC44LDEwLjgxIDIxLDExLjE2IDIxLDExLjVDMjEsMTEuODQgMjAuOCwxMi4xOSAyMC40NywxMi4zNkwxNSwxNUwxMi4zNiwyMS40N0MxMi4xOSwyMS44IDExLjg0LDIyIDExLjUsMjJDMTEuMTYsMjIgMTAuODEsMjEuOCAxMC42NCwyMS40N0w4LDE1TDIuNTMsMTIuMzZDMi4yLDEyLjE5IDIsMTEuODQgMiwxMS41QzIsMTEuMTYgMi4yLDEwLjgxIDIuNTMsMTAuNjRNNSwxMS41TDksMTNMMTEsMTdDMTEsMTcgMTIsMTcgMTIsMTdMMTQsMTNMMTgsMTEuNUwxNCwxMEwxMiw2TDEwLDEwTDUsMTEuNVoiIC8+PC9zdmc+') no-repeat center center;
    }
    
    .spacecraft.satellite {
      background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTUsMTJDNSwxMi41NSA1LjQ1LDEzIDYsMTNTNywxMi41NSA3LDEyIDYuNTUsMTEgNiwxMSA1LDExLjQ1IDUsMTJNNywxN0g5QzksMTUuOSA4LjEsMTUgNywxNVMwLDEgMCwxSDQwQzMuOSwyLjkgMywyIDMsN0wzLDggMyw5IEM0LjEsOSA1LDguMSA1LDdINi4xQzYuMTUsOC4yNSA3LjUsOS4xIDksMTAuMUwxMS41LDEyLjUgNi41LDE3LjUgOCwxOSAxMywxNEgxOEwxOSw3SDdDNyw4LjkgNy45LDEwIDksMTBDMTAuMSwxMCAxMSw5LjEgMTEsOEgxNC4xQzE0LjA1LDYuOCAxMy41LDYgMTIsNUw4LDEwSDdWMTdNMTIsMjBIMTRWMjJIMTJWMjBNMTIsMTZIMTRWMThIMTJWMTZNMTYsMC4xOCwwIDE4LDI0IDE2LDI0VjBNMTIsMEgxNFY0SDEyVjBNMTIsMTBIMTRWMTRIMTJWMTBNMTIsMjBIMTRWMjJIMTJWMjBaIiAvPjwvc3ZnPg==') no-repeat center center;
    }
    
    .spacecraft.ufo {
      background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTIsMTVDMi42NSwxMS4yNSA2LjI1LDYuNSAxMiw2LjVDMTcuNzUsNi41IDIxLjM1LDExLjI1IDIyLDE1SDBNMTIsMkMxMi4zMywxLjY3IDEyLjY3LDEuMzMgMTMsMS42N0MxMy4zMywyIDEzLDIuMzMgMTIuNjcsMi42N0MxMi4zMywzLjMzIDEyLDQgMTIsNS4zM0MxMiw1LjMzIDExLjY3LDUuMzMgMTEuNjcsNU0xNC4zMyw3LjMzQzEzLjMzLDcgMTIuNjcsNyAxMiw3QzUuMzMsNyAzLjMzLDEzLjMzIDMuMzMsMTRMMjAuNjcsMTRDMjAuMzMsMTMuMzMgMTguMzMsOCAxNC4zMyw3LjMzTTc1LDIxLjY3QzUuMzMsMjAuMzMgNS4zMywxOC42NyA1LjY3LDE3LjMzSDE4LjMzQzE4LjMzLDE4LjMzIDE4LjY3LDIwLjMzIDE5LDIxLjY3IiBwb2ludGVyLWV2ZW50cz0iYWxsIiBmaWxsLW9wYWNpdHk9IjAuNSIvPjwvc3ZnPg==') no-repeat center center;
    }
  </style>
</head>
<body>
  <div class="logo-container">
    <span class="logo-text">PLNT.earth</span>
    <div class="moon"></div>
  </div>
  
  <div class="theme-indicator" id="themeIndicator">
    Theme: <span id="themeName">Night</span><br>
    <span style="font-size: 12px; opacity: 0.7;">Right-click to change</span>
  </div>
  
  <div class="moon-countdown" id="moonCountdown"></div>
  <div class="clock" id="clock"></div>
  <button class="click-button" id="clickButton">Click Counter</button>
  <div class="click-log" id="clickLog"></div>
  <div class="info">Click anywhere...sound on. Right-click for themes. Bookmark this page.</div>
  
  <canvas id="spaceCanvas"></canvas>
  
  <script>
    // Set up canvas
    const canvas = document.getElementById('spaceCanvas');
    const ctx = canvas.getContext('2d');
    
    // Full screen dimensions
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Audio context for space sounds
    let audioContext;
    let spaceAmbience;
    let audioInitialized = false;
    
    // Theme management
    const themes = ['night', 'cosmic'];
    const themeNames = {
      'night': 'Night',
      'cosmic': 'Cosmic'
    };
    let currentTheme = 'night';
    
    // Load saved theme
    const savedTheme = localStorage.getItem('spaceScreensaverTheme');
    if (savedTheme && themes.includes(savedTheme)) {
      currentTheme = savedTheme;
      if (savedTheme === 'cosmic') {
        document.body.setAttribute('data-theme', 'cosmic');
      }
    }
    
    // Orb properties
    const orb = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      radius: Math.min(canvas.width, canvas.height) * 0.10,
      velocity: { x: 0.5, y: 0.4 },
      glow: 20,
      rotation: 0,
      shadowRotation: 0,
      textureRotation: 0,
      moonPhase: 0, // 0 = new moon, 0.5 = full moon, 1 = new moon again
      lastPhaseUpdate: Date.now()
    };
    
    // Stars array
    const stars = [];
    const numStars = 300;
    
    // Create stars
    for (let i = 0; i < numStars; i++) {
      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        radius: Math.random() * 1.5,
        alpha: Math.random(),
        blinkSpeed: 0.01 + Math.random() * 0.03
      });
    }
    
    // Spacecraft array
    const spacecraft = [];
    const spacecraftTypes = ['rocket', 'satellite', 'ufo'];
    
    // Logo moon orbit
    let moonAngle = 0;
    const logoElement = document.querySelector('.logo-container');
    const moonElement = document.querySelector('.moon');
    
    // Update moon position
    function updateMoon() {
      const t = moonAngle;
      const a = 50;
      const b = 25;
      
      const moonX = a * Math.cos(t);
      const moonY = b * Math.sin(t);
      
      moonElement.style.transform = `translate(${moonX}px, ${moonY}px)`;
      
      moonAngle += 0.01;
      if (moonAngle >= Math.PI * 2) {
        moonAngle = 0;
      }
    }
    
    // Initialize moon position
    moonElement.style.left = `${logoElement.offsetWidth}px`;
    moonElement.style.top = '12px';
    
    // Use requestAnimationFrame for smoother animation
    function animateMoon() {
      updateMoon();
      requestAnimationFrame(animateMoon);
    }
    
    // Start moon animation
    animateMoon();
    
    // Clock update function
    function updateClock() {
      const now = new Date();
      
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const seconds = now.getSeconds().toString().padStart(2, '0');
      
      document.getElementById('clock').textContent = `${hours}:${minutes}:${seconds}`;
    }
    
    // Calculate moon phase
    function calculateMoonPhase() {
      const synodicMonth = 29.53059;
      const refFullMoon = new Date(2025, 3, 12, 20, 22, 0);
      const now = new Date();
      
      const daysSinceRef = (now - refFullMoon) / (24 * 60 * 60 * 1000);
      
      let phase = (daysSinceRef / synodicMonth) % 1;
      if (phase < 0) phase += 1;
      
      phase = (phase + 0.5) % 1;
      
      return phase;
    }
    
    // Calculate time to next full moon
    function calculateTimeToFullMoon() {
      const nextFullMoon = new Date(2025, 3, 12, 20, 22, 0);
      const now = new Date();
      
      let targetFullMoon = new Date(nextFullMoon);
      while (targetFullMoon < now) {
        targetFullMoon = new Date(targetFullMoon.getTime() + (29.53 * 24 * 60 * 60 * 1000));
      }
      
      const timeDiff = targetFullMoon - now;
      const hoursToFullMoon = timeDiff / (1000 * 60 * 60);
      
      const days = Math.floor(hoursToFullMoon / 24);
      const hours = Math.floor(hoursToFullMoon % 24);
      const minutes = Math.floor((hoursToFullMoon * 60) % 60);
      
      const options = { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' };
      const fullMoonDateStr = targetFullMoon.toLocaleDateString('en-US', options);
      
      return {
        days,
        hours,
        minutes,
        fullMoonDateStr,
        totalHours: hoursToFullMoon
      };
    }
    
    // Update moon countdown display
    function updateMoonCountdown() {
      const timeToFullMoon = calculateTimeToFullMoon();
      const countdownElement = document.getElementById('moonCountdown');
      
      // Calculate illuminated percentage based on moon phase
      let illuminatedPercentage;
      const phase = orb.moonPhase;
      
      if (phase <= 0.5) {
        // New moon to full moon: illumination increases from 0% to 100%
        illuminatedPercentage = phase * 200;
      } else {
        // Full moon to new moon: illumination decreases from 100% to 0%
        illuminatedPercentage = (1 - phase) * 200;
      }
      
      illuminatedPercentage = Math.min(100, Math.max(0, illuminatedPercentage)).toFixed(1);
      
      countdownElement.innerHTML = `Next Full Moon in: ${timeToFullMoon.days}d ${timeToFullMoon.hours}h ${timeToFullMoon.minutes}m <br>` +
                                  `<span style="font-size: 12px; opacity: 0.8;">${timeToFullMoon.fullMoonDateStr} (${illuminatedPercentage}% illuminated)</span>`;
    }
    
    // Update orb color based on moon phase
    function updateOrbColor() {
      const currentPhase = calculateMoonPhase();
      orb.moonPhase = currentPhase;
    }
    
    // Initialize clock
    updateClock();
    setInterval(updateClock, 1000);
    
    // Initialize moon countdown
    updateMoonCountdown();
    setInterval(updateMoonCountdown, 6000);
    
    // Initial color update
    updateOrbColor();
    
    // Set interval to update the orb color every minute
    setInterval(updateOrbColor, 60000);
    
    // Add new spacecraft randomly
    function addSpacecraft() {
      if (spacecraft.length < 5 && Math.random() < 0.005) {
        const type = spacecraftTypes[Math.floor(Math.random() * spacecraftTypes.length)];
        const size = 30 + Math.random() * 40;
        
        const spacecraftElement = document.createElement('div');
        spacecraftElement.classList.add('spacecraft', type);
        spacecraftElement.style.width = `${size}px`;
        spacecraftElement.style.height = `${size / 2}px`;
        
        const fromLeft = Math.random() > 0.5;
        const xPos = fromLeft ? -size : canvas.width;
        const yPos = 100 + Math.random() * (canvas.height - 200);
        
        const newSpacecraft = {
          element: spacecraftElement,
          x: xPos,
          y: yPos,
          size: size,
          speed: 1 + Math.random() * 3,
          direction: fromLeft ? 1 : -1,
          rotation: Math.random() * 20 - 10,
          type: type
        };
        
        spacecraftElement.style.left = `${xPos}px`;
        spacecraftElement.style.top = `${yPos}px`;
        spacecraftElement.style.transform = `rotate(${newSpacecraft.rotation}deg) scaleX(${newSpacecraft.direction})`;
        document.body.appendChild(spacecraftElement);
        
        spacecraft.push(newSpacecraft);
        
        if (audioInitialized) {
          playRandomSpaceSound(200 + Math.random() * 1000);
        }
      }
    }
    
    // Update spacecraft positions
    function updateSpacecraft() {
      for (let i = spacecraft.length - 1; i >= 0; i--) {
        const craft = spacecraft[i];
        
        craft.x += craft.speed * craft.direction;
        craft.y += Math.sin(Date.now() / 1000 + i) * 0.5;
        
        craft.element.style.left = `${craft.x}px`;
        craft.element.style.top = `${craft.y}px`;
        
        if ((craft.direction > 0 && craft.x > canvas.width + craft.size) || 
            (craft.direction < 0 && craft.x < -craft.size)) {
          document.body.removeChild(craft.element);
          spacecraft.splice(i, 1);
        }
      }
    }
    
    // Draw stars
    function drawStars() {
      for (let i = 0; i < stars.length; i++) {
        const star = stars[i];
        
        star.alpha += star.blinkSpeed;
        if (star.alpha > 1 || star.alpha < 0.3) {
          star.blinkSpeed = -star.blinkSpeed;
        }
        
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
        ctx.fill();
      }
    }
    
    // Draw orb with moon phase animation
    function drawOrb() {
      // Update orb position
      orb.x += orb.velocity.x;
      orb.y += orb.velocity.y;
      
      // Bounce off edges
      if (orb.x - orb.radius <= 0 || orb.x + orb.radius >= canvas.width) {
        orb.velocity.x = -orb.velocity.x;
        if (audioInitialized) playRandomSpaceSound(400);
      }
      
      if (orb.y - orb.radius <= 0 || orb.y + orb.radius >= canvas.height) {
        orb.velocity.y = -orb.velocity.y;
        if (audioInitialized) playRandomSpaceSound(400);
      }
      
      // Update rotations - much slower
      orb.shadowRotation += 0.003;
      orb.textureRotation -= 0.002; // Opposite direction
      
      // Get current theme colors
      const styles = getComputedStyle(document.body);
      const fullMoonColor = styles.getPropertyValue('--full-moon-color').trim();
      const newMoonColor = styles.getPropertyValue('--new-moon-color').trim();
      
      // Calculate moon phase percentage (0 to 1)
      const phasePercentage = orb.moonPhase;
      
      // Calculate brightness factor for effects
      const brightness = phasePercentage <= 0.5 ? phasePercentage * 2 : (1 - phasePercentage) * 2;
      
      // Save context and translate to orb position
      ctx.save();
      ctx.translate(orb.x, orb.y);
      ctx.rotate(orb.shadowRotation);
      
      // Create circular clipping path
      ctx.beginPath();
      ctx.arc(0, 0, orb.radius, 0, Math.PI * 2);
      ctx.clip();
      
      // Draw the full moon base (light side)
      ctx.fillStyle = fullMoonColor;
      ctx.fillRect(-orb.radius, -orb.radius, orb.radius * 2, orb.radius * 2);
      
      // Draw surface texture circles (rotating opposite to shadow)
      ctx.save();
      ctx.rotate(orb.textureRotation - orb.shadowRotation); // Counter the shadow rotation and add texture rotation
      
      if (brightness > 0.1) {
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const x = Math.cos(angle) * (orb.radius * 0.6);
          const y = Math.sin(angle) * (orb.radius * 0.6);
          const size = orb.radius * 0.15;
          
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          // Create color based on full moon color with transparency
          const rgbMatch = fullMoonColor.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
          if (rgbMatch) {
            const r = parseInt(rgbMatch[1], 16);
            const g = parseInt(rgbMatch[2], 16);
            const b = parseInt(rgbMatch[3], 16);
            ctx.fillStyle = `rgba(${r * 0.8}, ${g * 0.8}, ${b * 0.8}, ${0.3 * brightness})`;
          } else {
            ctx.fillStyle = `rgba(200, 200, 100, ${0.3 * brightness})`;
          }
          ctx.fill();
        }
        
        // Draw center feature if visible
        if (brightness > 0.3) {
          ctx.beginPath();
          ctx.arc(0, 0, orb.radius * 0.3, 0, Math.PI * 2);
          const rgbMatch = fullMoonColor.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
          if (rgbMatch) {
            const r = parseInt(rgbMatch[1], 16);
            const g = parseInt(rgbMatch[2], 16);
            const b = parseInt(rgbMatch[3], 16);
            ctx.fillStyle = `rgba(${r * 0.9}, ${g * 0.9}, ${b * 0.9}, ${0.5 * brightness})`;
          } else {
            ctx.fillStyle = `rgba(220, 220, 110, ${0.5 * brightness})`;
          }
          ctx.fill();
        }
      }
      
      ctx.restore(); // Restore from texture rotation
      
      // Draw the shadow
      ctx.fillStyle = newMoonColor;
      
      // Calculate shadow position based on phase
      const isWaxing = phasePercentage < 0.5;
      let shadowCoverage;
      
      if (isWaxing) {
        // New moon to full moon (0 to 0.5)
        shadowCoverage = 1 - (phasePercentage * 2);
      } else {
        // Full moon to new moon (0.5 to 1)
        shadowCoverage = (phasePercentage - 0.5) * 2;
      }
      
      // Draw shadow using an arc
      ctx.beginPath();
      if (phasePercentage < 0.5) {
        // Waxing: shadow recedes from right to left
        const startAngle = -Math.PI / 2;
        const endAngle = Math.PI / 2;
        const ellipseWidth = orb.radius * 2 * shadowCoverage;
        
        ctx.arc(0, 0, orb.radius, startAngle, endAngle, false);
        if (shadowCoverage > 0.01) {
          ctx.ellipse(0, 0, ellipseWidth / 2, orb.radius, 0, endAngle, startAngle, true);
        }
      } else {
        // Waning: shadow grows from left to right
        const startAngle = Math.PI / 2;
        const endAngle = -Math.PI / 2;
        const ellipseWidth = orb.radius * 2 * shadowCoverage;
        
        ctx.arc(0, 0, orb.radius, startAngle, endAngle, false);
        if (shadowCoverage > 0.01) {
          ctx.ellipse(0, 0, ellipseWidth / 2, orb.radius, 0, endAngle, startAngle, true);
        }
      }
      ctx.closePath();
      ctx.fill();
      
      // Restore context
      ctx.restore();
      
      // Add softer glow effect with multiple layers
      const glowLayers = 3;
      for (let i = 0; i < glowLayers; i++) {
        const layerSize = 1.2 + (i * 0.2);
        const layerOpacity = (0.1 - (i * 0.03)) * brightness;
        
        const gradient = ctx.createRadialGradient(
          orb.x, orb.y, orb.radius,
          orb.x, orb.y, orb.radius * layerSize
        );
        gradient.addColorStop(0, `rgba(255, 255, 255, 0)`);
        gradient.addColorStop(0.5, `rgba(255, 255, 255, ${layerOpacity * 0.5})`);
        gradient.addColorStop(1, `rgba(255, 255, 255, ${layerOpacity})`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(orb.x, orb.y, orb.radius * layerSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Update rotation
      orb.rotation += 0.002;
    }
    
    // Initialize audio
    function initAudio() {
      if (audioInitialized) return;
      
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        spaceAmbience = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        spaceAmbience.type = 'sine';
        spaceAmbience.frequency.value = 80;
        
        gainNode.gain.value = 0.03;
        
        spaceAmbience.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        spaceAmbience.start();
        
        const lfo = audioContext.createOscillator();
        const lfoGain = audioContext.createGain();
        
        lfo.type = 'sine';
        lfo.frequency.value = 0.05;
        lfoGain.gain.value = 20;
        
        lfo.connect(lfoGain);
        lfoGain.connect(spaceAmbience.frequency);
        
        lfo.start();
        
        audioInitialized = true;
        
        setTimeout(() => playRandomSpaceSound(1000), 500);
      } catch (error) {
        console.error("Error initializing audio:", error);
      }
    }
    
    // Play random space sound
    function playRandomSpaceSound(duration = 500) {
      if (!audioInitialized) return;
      
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        const frequency = 200 + Math.random() * 500;
        const type = ['sine', 'square', 'sawtooth', 'triangle'][Math.floor(Math.random() * 4)];
        
        oscillator.type = type;
        oscillator.frequency.value = frequency;
        
        gainNode.gain.value = 0;
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.1);
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + (duration / 1000));
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + (duration / 1000));
      } catch (error) {
        console.error("Error playing sound:", error);
      }
    }
    
    // Theme switching
    function switchTheme() {
      if (currentTheme === 'night') {
        currentTheme = 'cosmic';
        document.body.setAttribute('data-theme', 'cosmic');
      } else {
        currentTheme = 'night';
        document.body.removeAttribute('data-theme');
      }
      
      localStorage.setItem('spaceScreensaverTheme', currentTheme);
      
      // Show theme indicator
      const indicator = document.getElementById('themeIndicator');
      const themeName = document.getElementById('themeName');
      themeName.textContent = themeNames[currentTheme];
      indicator.classList.add('show');
      
      setTimeout(() => {
        indicator.classList.remove('show');
      }, 2000);
      
      // Play sound
      if (audioInitialized) {
        playRandomSpaceSound(300);
      }
    }
    
    // Animation loop
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      drawStars();
      drawOrb();
      
      addSpacecraft();
      updateSpacecraft();
      
      requestAnimationFrame(animate);
    }
    
    // Start animation
    animate();
    
    // Window resize event
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      if (orb.x < orb.radius || orb.x > canvas.width - orb.radius ||
          orb.y < orb.radius || orb.y > canvas.height - orb.radius) {
        orb.x = canvas.width / 2;
        orb.y = canvas.height / 2;
      }
    });
    
    // Click counter functionality
    let clickCount = 0;
    let clickLog = [];
    const clickButton = document.getElementById('clickButton');
    const clickLogElement = document.getElementById('clickLog');
    
    function loadClickData() {
      const savedCount = localStorage.getItem('spaceScreensaverClickCount');
      const savedLog = localStorage.getItem('spaceScreensaverClickLog');
      
      if (savedCount !== null) {
        clickCount = parseInt(savedCount, 10);
      }
      
      if (savedLog !== null) {
        try {
          clickLog = JSON.parse(savedLog);
          clickLog.forEach(entry => {
            addLogEntry(entry.time, entry.count, false);
          });
        } catch (e) {
          console.error('Error parsing saved click log:', e);
          clickLog = [];
        }
      }
      
      clickButton.textContent = `Clicks: ${clickCount}`;
    }
    
    function addLogEntry(timestamp, count, save = true) {
      const entry = document.createElement('p');
      entry.textContent = `${timestamp} - Click #${count}`;
      clickLogElement.appendChild(entry);
      
      clickLogElement.scrollTop = clickLogElement.scrollHeight;
      
      if (save) {
        clickLog.push({ time: timestamp, count: count });
        
        if (clickLog.length > 50) {
          clickLog.shift();
        }
        
        localStorage.setItem('spaceScreensaverClickLog', JSON.stringify(clickLog));
      }
    }
    
    clickButton.addEventListener('click', (e) => {
      e.stopPropagation();
      
      clickCount++;
      clickButton.textContent = `Clicks: ${clickCount}`;
      
      const now = new Date();
      const timestamp = now.toLocaleDateString() + ' ' + now.toLocaleTimeString();
      
      addLogEntry(timestamp, clickCount);
      
      clickLogElement.style.display = 'block';
      
      localStorage.setItem('spaceScreensaverClickCount', clickCount.toString());
      
      if (audioInitialized) {
        playRandomSpaceSound(300);
      } else {
        initAudio();
        playRandomSpaceSound(300);
      }
    });
    
    loadClickData();
    
    // Right-click for theme switching
    document.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      switchTheme();
    });
    
    // Touch handling for mobile
    let touchTimer;
    let touchCount = 0;
    
    document.addEventListener('touchstart', (e) => {
      if (e.target === clickButton || clickLogElement.contains(e.target)) {
        return;
      }
      
      touchCount++;
      
      if (touchCount === 1) {
        touchTimer = setTimeout(() => {
          touchCount = 0;
        }, 400);
      } else if (touchCount === 2) {
        clearTimeout(touchTimer);
        touchCount = 0;
        e.preventDefault();
        switchTheme();
      }
    });
    
    // Document click for fullscreen toggle
    document.addEventListener('click', (e) => {
      if (e.target === clickButton || clickLogElement.contains(e.target)) {
        return;
      }
      
      if (!audioInitialized) {
        initAudio();
      }
      
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen()
          .then(() => {
            document.body.classList.add('hide-cursor');
          })
          .catch(err => {
            console.error('Error attempting to enable fullscreen:', err);
          });
      } else {
        document.exitFullscreen()
          .then(() => {
            document.body.classList.remove('hide-cursor');
          })
          .catch(err => {
            console.error('Error attempting to exit fullscreen:', err);
          });
      }
    });
  </script>
  
  <!-- Vercel Analytics -->
  <script>
    window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
  </script>
  <script defer src="/_vercel/insights/script.js"></script>
  
  <!-- Vercel Speed Insights -->
  <script defer src="/_vercel/speed-insights/script.js"></script>
</body>
</html>
        
        